<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Get Started With SparseOperationKit &mdash; SparseOperationKit  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sparse Operation Kit Notebooks" href="../examples/examples.html" />
    <link rel="prev" title="SparseOperationKit" href="../intro_link.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SparseOperationKit
          </a>
              <div class="version">
                2.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro_link.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Get Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#table-of-contents">Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#importing-sparseoperationkit">Importing SparseOperationKit</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initializing-sok-with-tensorflow-and-horovod">Initializing SOK with TensorFlow and Horovod</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-sok-distributed-variables">Defining SOK Distributed Variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sok-variable">sok.Variable</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sok-dynamicvariable">sok.DynamicVariable</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-sok-for-lookup">Using SOK for Lookup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performing-backward-and-optimizer-update">Performing Backward and Optimizer Update</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interaction-between-sok-variable-and-tensorflow-tensor">Interaction Between SOK Variable and TensorFlow Tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dumping-and-loading-indices-and-weights">Dumping and Loading Indices and Weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="#incremental-dump-of-keys-and-values">Incremental Dump of Keys and Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#additional-resources">Additional Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes/release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../env_vars/env_vars.html">Environment Variables</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SparseOperationKit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Get Started With SparseOperationKit</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/get_started/get_started.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="get-started-with-sparseoperationkit">
<h1>Get Started With SparseOperationKit<a class="headerlink" href="#get-started-with-sparseoperationkit" title="Permalink to this heading"></a></h1>
<p>This document will walk you through simple demos to get you familiar with SparseOperationKit (SOK).</p>
<section id="table-of-contents">
<h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this heading"></a></h2>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#introduction"><span class="xref myst">Introduction</span></a></p></li>
<li><p><a class="reference internal" href="#installation"><span class="xref myst">Installation</span></a></p></li>
<li><p><a class="reference internal" href="#importing-sparseoperationkit"><span class="xref myst">Importing SparseOperationKit</span></a></p></li>
<li><p><a class="reference internal" href="#initializing-sok-with-tensorflow-and-horovod"><span class="xref myst">Initializing SOK with TensorFlow and Horovod</span></a></p></li>
<li><p><a class="reference internal" href="#defining-sok-distributed-variables"><span class="xref myst">Defining SOK Distributed Variables</span></a></p></li>
<li><p><a class="reference internal" href="#using-sok-for-lookup"><span class="xref myst">Using SOK for Lookup</span></a></p></li>
<li><p><a class="reference internal" href="#performing-backward-and-optimizer-update"><span class="xref myst">Performing Backward and Optimizer Update</span></a></p></li>
<li><p><a class="reference internal" href="#interaction-between-sok-variable-and-tensorflow-tensor"><span class="xref myst">Interaction Between SOK Variable and TensorFlow Tensor</span></a></p></li>
<li><p><a class="reference internal" href="#dumping-and-loading-indices-and-weights"><span class="xref myst">Dumping and Loading Indices and Weights</span></a></p></li>
<li><p><a class="reference internal" href="#incremental-dump-of-keys-and-values"><span class="xref myst">Incremental Dump of Keys and Values</span></a></p></li>
<li><p><a class="reference internal" href="#additional-resources"><span class="xref myst">Additional Resources</span></a></p></li>
</ol>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>SparseOperationKit (SOK) is a toolkit designed to facilitate the handling of sparse operations in TensorFlow, particularly for distributed training scenarios. It supports TensorFlow versions 1.15 and &gt;=2.6 and integrates seamlessly with Horovod for communication.</p>
</section>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this heading"></a></h2>
<p>Refer to the <a class="reference external" href="https://nvidia-merlin.github.io/HugeCTR/sparse_operation_kit/master/intro_link.html#installation"><em>Installation</em> section</a> to install SparseOperationKit on your system.</p>
</section>
<section id="importing-sparseoperationkit">
<h2>Importing SparseOperationKit<a class="headerlink" href="#importing-sparseoperationkit" title="Permalink to this heading"></a></h2>
<p>To get started, import SparseOperationKit as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sparse_operation_kit</span> <span class="k">as</span> <span class="nn">sok</span>
</pre></div>
</div>
<p>SOK automatically detects the TensorFlow version in use, ensuring a consistent interface regardless of the version.</p>
</section>
<section id="initializing-sok-with-tensorflow-and-horovod">
<h2>Initializing SOK with TensorFlow and Horovod<a class="headerlink" href="#initializing-sok-with-tensorflow-and-horovod" title="Permalink to this heading"></a></h2>
<p>Currently, SOK uses Horovod for communication. Begin by importing Horovod and correctly binding a GPU to each process.For detailed instructions on binding GPUs with Horovod, please refer to the <a class="reference external" href="https://horovod.readthedocs.io/en/stable/tensorflow.html#horovod-with-tensorflow">Horovod with TensorFlow guide</a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">horovod.tensorflow</span> <span class="k">as</span> <span class="nn">hvd</span>

<span class="kn">import</span> <span class="nn">sparse_operation_kit</span> <span class="k">as</span> <span class="nn">sok</span>


<span class="n">hvd</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">gpus</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">list_physical_devices</span><span class="p">(</span><span class="s2">&quot;GPU&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">gpu</span> <span class="ow">in</span> <span class="n">gpus</span><span class="p">:</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">set_memory_growth</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="k">if</span> <span class="n">gpus</span><span class="p">:</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">set_visible_devices</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="n">hvd</span><span class="o">.</span><span class="n">local_rank</span><span class="p">()],</span> <span class="s2">&quot;GPU&quot;</span><span class="p">)</span>  <span class="c1"># nopep8</span>

<span class="n">sok</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="defining-sok-distributed-variables">
<h2>Defining SOK Distributed Variables<a class="headerlink" href="#defining-sok-distributed-variables" title="Permalink to this heading"></a></h2>
<p>SOK provides two types of distributed variables for storing sparse embedding weights: <code class="docutils literal notranslate"><span class="pre">sok.Variable</span></code> and <code class="docutils literal notranslate"><span class="pre">sok.DynamicVariable</span></code>.</p>
<section id="sok-variable">
<h3>sok.Variable<a class="headerlink" href="#sok-variable" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">sok.Variable</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">tf.Variable</span></code> but includes distributed methods. It supports two partition methods:</p>
<ol class="arabic simple">
<li><p><strong>Default Partition Method</strong>: Distributes embedding IDs across GPUs in a round-robin manner.</p></li>
<li><p><strong>Localized Partition Method</strong>: Assigns embedding tables to specific GPUs to reduce lookup communication overhead.</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Default method of sok.Variable is Distributed method,</span>
<span class="c1"># If there are 2 GPUs in total, the shape of v1 on GPU0 will be [9, 3] and the shape</span>
<span class="c1"># on GPU1 will be [8, 3]</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">sok</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1">#If you want to assign a sok.Variable to a specific GPU, add the parameter mode=“localized:gpu_id” when defining sok.variable, where gpu_id refers to the rank number of a GPU in Horovod</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">sok</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;localized:0&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;v1:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;v2:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="sok-dynamicvariable">
<h3>sok.DynamicVariable<a class="headerlink" href="#sok-dynamicvariable" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">sok.DynamicVariable</span></code> uses a hash table as its backend and supports dynamic memory usage. It has two types of backends:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/NVIDIA-Merlin/HierarchicalKV">HierarchicalKV (HKV)</a></p>
<ul>
<li><p><strong>HierarchicalKV</strong> provides hierarchical key-value storage</p></li>
<li><p>It stores key-value pairs (feature-embedding) on high-bandwidth memory (HBM) of GPUs and in host memory.</p></li>
<li><p>HKV can provide an eviction feature to control the memory usage of the entire embedding table.</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://github.com/NVIDIA-Merlin/HugeCTR/tree/main/sparse_operation_kit/kit_src/variable/impl/dynamic_embedding_table">DynamicEmbeddingTable (DET)</a></p>
<ul>
<li><p><strong>DynamicEmbeddingTable</strong> stores all key-value pairs in GPU memory</p></li>
<li><p>The lookup performance of DET is slightly better than HKV, but it lacks eviction functionality and cannot control the memory size of the embedding table.</p></li>
</ul>
</li>
</ul>
<p>Due to the more comprehensive features of HKV, it is the default backend for <code class="docutils literal notranslate"><span class="pre">sok.DynamicVariable</span></code>. If you want to use DET, you can specify the input parameter <code class="docutils literal notranslate"><span class="pre">var_type=&quot;hbm&quot;</span></code> when declaring <code class="docutils literal notranslate"><span class="pre">sok.DynamicVariable</span></code>. Typically, DET is suitable to make quick prototypes and verify correctness because it requires fewer arguments when declaring.</p>
<p>Here is a code sample showing how to declare a <code class="docutils literal notranslate"><span class="pre">sok.DynamicVariable</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># To apply for different backends of dynamic embedding, you need to specify var_type when defining sok.DynamicVariable. &#39;hbm&#39; corresponds to DET, and &#39;hybrid&#39; corresponds to HKV.</span>
<span class="n">v1</span> <span class="o">=</span> <span class="n">sok</span><span class="o">.</span><span class="n">DynamicVariable</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span><span class="n">var_type</span><span class="o">=</span><span class="s2">&quot;hbm&quot;</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="s2">&quot;normal&quot;</span><span class="p">)</span>

<span class="c1">#init_capacity and max_capacity are parameters accepted by the HKV table. The meanings of these parameters can be found in the HKV documentation.</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">sok</span><span class="o">.</span><span class="n">DynamicVariable</span><span class="p">(</span>
    <span class="n">dimension</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
    <span class="n">var_type</span><span class="o">=</span><span class="s2">&quot;hybrid&quot;</span><span class="p">,</span>
    <span class="n">initializer</span><span class="o">=</span><span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
    <span class="n">init_capacity</span><span class="o">=</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
    <span class="n">max_capacity</span><span class="o">=</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
    <span class="n">max_hbm_for_vectors</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;v1:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;v2:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>As seen from the above example, using HKV as the backend for <code class="docutils literal notranslate"><span class="pre">sok.DynamicVariable</span></code> requires passing more arguments. These arguments are needed when creating the HKV hash table.
For details, you can refer to the arguments from <a class="reference external" href="https://github.com/NVIDIA-Merlin/HierarchicalKV?tab=readme-ov-file#configuration-options">HKV Configuration Options</a></p>
<p>When not familiar with HKV arguments, it is recommended to set the following three arguments</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">init_capacity</span></code>: When initializing the HKV hash table, the number of key-values. This number must be a power of two due to HKV’s limitations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_capacity</span></code>: The maximum number of key-value pairs the HKV hash table can grow to. After reaching this number, the HKV hash table will not grow any further. This number must be a power of two due to HKV’s limitations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_hbm_for_vectors</span></code>: During the use of the HKV hash table, how much GPU memory can the values can occupy at most, in gigabytes.</p></li>
</ul>
</section>
</section>
<section id="using-sok-for-lookup">
<h2>Using SOK for Lookup<a class="headerlink" href="#using-sok-for-lookup" title="Permalink to this heading"></a></h2>
<p>SOK provides the <code class="docutils literal notranslate"><span class="pre">lookup_sparse</span></code> API for lookups, which accepts <code class="docutils literal notranslate"><span class="pre">tf.RaggedTensor</span></code> or <code class="docutils literal notranslate"><span class="pre">tf.SparseTensor</span></code> as indices. It can simultaneously lookup multiple instances of <code class="docutils literal notranslate"><span class="pre">sok.variable</span></code> by fusing their operations as a single one.</p>
<p>How to use the <code class="docutils literal notranslate"><span class="pre">sok.lookup_sparse</span></code> is consistent with <code class="docutils literal notranslate"><span class="pre">tf.nn.embedding_lookup_sparse</span></code>, except that it can accept the lists of  <code class="docutils literal notranslate"><span class="pre">sok.Variable</span></code>, <code class="docutils literal notranslate"><span class="pre">sp_id</span></code>, and <code class="docutils literal notranslate"><span class="pre">combiner</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">indices1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span>
    <span class="n">indices</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">dense_shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;indices1:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">indices1</span><span class="p">)</span>
<span class="c1"># indices1: batch_size=2, max_hotness=3</span>
<span class="c1"># [[1, 1]</span>
<span class="c1">#  [3, 4, 5]]</span>

<span class="n">indices2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span>
    <span class="n">indices</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dense_shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;indices2:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">indices2</span><span class="p">)</span>
<span class="c1"># indices2: batch_size=2, max_hotness=2</span>
<span class="c1"># [[1]</span>
<span class="c1">#  [2, 3]]</span>

<span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
    <span class="n">embeddings</span> <span class="o">=</span> <span class="n">sok</span><span class="o">.</span><span class="n">lookup_sparse</span><span class="p">(</span>
        <span class="p">[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">],</span> <span class="p">[</span><span class="n">indices1</span><span class="p">,</span> <span class="n">indices2</span><span class="p">],</span> <span class="n">combiners</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">embedding</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">embeddings</span><span class="p">):</span>
        <span class="n">loss</span> <span class="o">+=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;embedding</span><span class="si">%d</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">embedding</span><span class="p">)</span>
    <span class="c1"># embedding1: [[6,  8,  10]</span>
    <span class="c1">#              [36, 39, 42]]</span>
    <span class="c1"># embedding2: [[5,  6,  7,  8,  9</span>
    <span class="c1">#              [25, 27, 29, 31, 33]]</span>

</pre></div>
</div>
</section>
<section id="performing-backward-and-optimizer-update">
<h2>Performing Backward and Optimizer Update<a class="headerlink" href="#performing-backward-and-optimizer-update" title="Permalink to this heading"></a></h2>
<p>For the backward process, <code class="docutils literal notranslate"><span class="pre">sok.lookup_sparse</span></code> behaves like otherTensorFlow operations.
However, raw TensorFlow optimizers cannot apply gradients to <code class="docutils literal notranslate"><span class="pre">sok.DynamicVariable</span></code>. Use <code class="docutils literal notranslate"><span class="pre">sok.OptimizerWrapper</span></code> to wrap the optimizer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#define a tf optimizer , and then warp it to sok_optimizer, then can use it on sok.DynamicVariable`</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">sok_optimizer</span> <span class="o">=</span> <span class="n">sok</span><span class="o">.</span><span class="n">OptimizerWrapper</span><span class="p">(</span><span class="n">optimizer</span><span class="p">)</span>
<span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">grad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grads</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;grad</span><span class="si">%d</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">grad</span><span class="p">)</span>

<span class="n">sok_optimizer</span><span class="o">.</span><span class="n">apply_gradients</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;v1:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;v2:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="interaction-between-sok-variable-and-tensorflow-tensor">
<h2>Interaction Between SOK Variable and TensorFlow Tensor<a class="headerlink" href="#interaction-between-sok-variable-and-tensorflow-tensor" title="Permalink to this heading"></a></h2>
<p>SOK provides <code class="docutils literal notranslate"><span class="pre">sok.export</span></code> and <code class="docutils literal notranslate"><span class="pre">sok.assign</span></code> APIs for interaction between <code class="docutils literal notranslate"><span class="pre">sok.Variable</span></code> and <code class="docutils literal notranslate"><span class="pre">TensorFlow.tensor</span></code>.</p>
<p><strong>Note</strong>: since SOKvariables are distributed across multiple GPUs, the <code class="docutils literal notranslate"><span class="pre">sok.export</span></code> and <code class="docutils literal notranslate"><span class="pre">sok.assign</span></code> APIs will only export and assign the portion of the data on the local GPU. This means that those operations do not handle the global size of the variables but rather focus on the local segments specific to each GPU.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Generate the keys and values you want to assign to sok.Variable</span>
<span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;CPU&quot;</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">24</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">sok</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

<span class="c1">#Export the keys and values of sok.Variable to two tf.tensor placed on the CPU.</span>
<span class="n">ex_v1_indices</span><span class="p">,</span> <span class="n">ex_v1_values</span> <span class="o">=</span> <span class="n">sok</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ex_v1_indices:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ex_v1_indices</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ex_v1_values:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ex_v1_values</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="dumping-and-loading-indices-and-weights">
<h2>Dumping and Loading Indices and Weights<a class="headerlink" href="#dumping-and-loading-indices-and-weights" title="Permalink to this heading"></a></h2>
<p>SOK provides <code class="docutils literal notranslate"><span class="pre">sok.dump</span></code> and <code class="docutils literal notranslate"><span class="pre">sok.load</span></code> for dumping/loading trained keys and values to/from the filesystem.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sok.dump</span></code> dumps the keys, values, and optimizer states as multiple binary files with a simple file header.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sok.load</span></code> loads the keys, values, and optimizer states, from the binary files created by <code class="docutils literal notranslate"><span class="pre">sok.dump</span></code>, automatically distributing them to the GPUs.”</p></li>
</ul>
<p><strong>Note</strong>:optimizer states are optional. If they are unspecified in calling the APIs above, only the keys and values are loaded.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;./weights&quot;</span>
<span class="n">sok_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">]</span>
<span class="n">sok</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s2">&quot;./weight&quot;</span><span class="p">,</span> <span class="n">sok_vars</span><span class="p">,</span> <span class="n">sok_optimizer</span><span class="p">)</span>
<span class="n">sok</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;./weight&quot;</span><span class="p">,</span> <span class="n">sok_vars</span><span class="p">,</span> <span class="n">sok_optimizer</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="incremental-dump-of-keys-and-values">
<h2>Incremental Dump of Keys and Values<a class="headerlink" href="#incremental-dump-of-keys-and-values" title="Permalink to this heading"></a></h2>
<p>SOK supports incremental dumps, allowing you to dump keys and values updated after a specific time threshold (in UTC) into a Numpy array.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytz</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="c1">#should convert datatime to utc time</span>
<span class="n">utc_time_threshold</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>

<span class="c1">#####</span>
<span class="c1">#Need do some lookup forward and backward or sok.assign</span>
<span class="c1">#####</span>

<span class="n">sok_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">]</span>
<span class="c1">#keys and values are Numpy array</span>
<span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">sok</span><span class="o">.</span><span class="n">incremental_model_dump</span><span class="p">(</span><span class="n">sok_vars</span><span class="p">,</span> <span class="n">utc_time_threshold</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="additional-resources">
<h2>Additional Resources<a class="headerlink" href="#additional-resources" title="Permalink to this heading"></a></h2>
<p>For more examples and API descriptions, see the <a class="reference external" href="https://nvidia-merlin.github.io/HugeCTR/sparse_operation_kit/master/examples/examples.html">Example section</a> and <a class="reference external" href="https://nvidia-merlin.github.io/HugeCTR/sparse_operation_kit/master/api/index.html">API section</a>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../intro_link.html" class="btn btn-neutral float-left" title="SparseOperationKit" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../examples/examples.html" class="btn btn-neutral float-right" title="Sparse Operation Kit Notebooks" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, NVIDIA.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    master: sok_v2.1.0
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="../../sok_v1.0.0/get_started/get_started.html">sok_v1.0.0</a></dd>
      <dd><a href="../../sok_v1.1.0/get_started/get_started.html">sok_v1.1.0</a></dd>
      <dd><a href="../../sok_v1.1.1/get_started/get_started.html">sok_v1.1.1</a></dd>
      <dd><a href="../../sok_v1.1.2/get_started/get_started.html">sok_v1.1.2</a></dd>
      <dd><a href="../../sok_v1.1.4/get_started/get_started.html">sok_v1.1.4</a></dd>
      <dd><a href="../../sok_v2.0.0/get_started/get_started.html">sok_v2.0.0</a></dd>
      <dd><a href="get_started.html">sok_v2.1.0</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>